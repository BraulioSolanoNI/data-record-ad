[[_TOC_]]

#Overview

We have a template that simplifies the creation of new PEs. 

To create a new plug-in, install the latest IO Plugin Creation Tool.

In LabVIEW Navigate to File->Create Project->ADAS->ADAS IO Plugin Template

Overlay's for newly created plugin classes are defined here by clicking Edit Overlay.

After the project is built...

1. Set Configuration.ctl in the new plugin to include configuration parameters that will be passed into the plugin's constructor..
a. Local data (e.g. file refnums, variables) that are generated and used internal to the plugin can be stored in the Class Control outside of the Configuration cluster.

1. Implement your overrides: Initialize, Configure Session, Process, etc. 

1. Configure terminal names for input and output streams. The following three values must match for data to be successfully sent (default value for all three is "Output":
a. The terminal name wired into System Interface Write.
b. The name of the Stream Spec in the Controller class's Read Output Streams.vi.
c. The name specified in the "Interface" segment of the plugin's XML.

## Creating a New Plugin From Template

Install all Data Record AD  software
In LabVIEW, create a new ADAS IO Plugin:

![image.png](/.attachments/image-5fe562c6-4088-423a-b039-b266ba4598a4.png)


Select a name for the IO Plugin and a location where you'd like the files to be generated (the IO Plugin Directory will be different on your system)

![image.png](/.attachments/image-b856112a-4d00-4582-9a22-81e725ab700a.png)

Click Finish.  LabVIEW will now generate a new project with everything you need for an IO Plugin.
Navigate to the location you chose for the IO Plugin Directory and open the project:

![image.png](/.attachments/image-55903fce-344b-4906-8e26-e1a4d90d2a7c.png)

Most of the files generated by the template are needed for the plugin to operate, but do not need to be (and should not be) modified.

To find a list of what actions should be taken to customize the plugin, open the Bookmark Manager (View>>Bookmark Manager).

![image.png](/.attachments/image-5487e9a9-9198-4f30-9c19-d3072f5f2b0a.png)

Each of the #TODO bookmarks shows a place within the plugin where you can customize the behavior.

## Plugin State Machine

Each plugin defines behaviors for various states that the plugin will transition through during system execution.

The underlying engine used for the Data Record AD software (known as the Processing Element Framework, or PEF), controls the state machine of the plugins.  It is responsible for calling the correct state VI of the plugins at the appropriate times, as well as for loading and unloading the plugins based on the configuration file.  

Any information that needs to be retained between calls to the state VIs (such as file references, driver session references, counters, etc) need to be stored in the class private data of the plugin.  PEF will manage passing the class private data of a plugin to each call of the plugin's state VIs.  Do not store any data in uninitialized shift registers or feedback nodes or the front panel.  Any data to be retained between calls (even to the same state, such as Process) must be stored in the class private data cluster to work.

Because datalogger plugins extend the Processing Element Framework, they are sometimes referred to as PEs (Processing Elements).

To simplify the creation of datalogger plugins, a project template is provided that defines all necessary functions.  A plugin developer will need to modify the functions generated by the template to give the new plugin the desired behavior.

![pe_statemachine.png](/.attachments/pe_statemachine-5c0dc307-bca6-4d06-9756-5da260211655.png)


## Functions to Modify

The main parts of the project that you will modify are the VIs in the States folder of the plugin class.  Each plugin defines behavior for the different states that the ADAS engine supports.  

### Configuration

- #### Configuration.ctl
  - ![image.png](/.attachments/image-49381327-f108-41d3-96d5-4012fa5d8269.png)

- #### Plugin Class Private Data 
  - (ExamplePlugin.ctl in this example)
  - ![image.png](/.attachments/image-d3a03e82-0b24-45f6-9aec-c9cc68b84380.png)
  - Keep the Configuration item in the class private data - this is the type definition you modified in the previous step (Configuration.ctl).  Add whatever other items your plugin needs at run time to the cluster.  For example, if your plugin reads data from a UDP port, you might store the UDP connection reference in addition to the Configuration type def.  If your plugin writes incoming data to a TDMS file, you might store the TDMS file reference.
    - Any new items you add to the class private data should also be exposed via accessor methods and property nodes.  Once you have added the items to the class private data, right-click on the class and select New>>VI for Data Member Access, select the new items, configure for Read and Write access, enable the Make available through Property Nodes option and store them in an Accessors folder.  See screenshot below for an example:
  - ![image.png](/.attachments/image-8dd616c9-e06d-4ef7-8b78-42343ee6bdc9.png)

- #### Default Configuration Parameters.vi
  - This function is used to tell the configuration editor what values to use as defaults for the configuration cluster.  It has a constant of the Configuration.ctl typedef modified earlier.  Populate the constant with the correct default values for your plugin.
  - ![image.png](/.attachments/image-98bdfa33-c682-4714-9382-1241071a410b.png)

- ### Initialize
  - This is called once for the entire lifetime of the plugin, and is where the timing option for the plugin is set if the value is not based on the configuration file. 
  - Initialize is called before the plugin loads its configuration
  - Timing options:
    - Periodic: Specify a millisecond period for the Process loop to run at.  Useful for status data sources such as system health that don't get timing from a hardware driver call.  Avoid using this for process or sink PEs, since if the data source produces data more quickly than the data sink runs, a memory growth will occur in the queue linking the plugins.
    - Immediate: Run the process loop as quickly as possible, with no added delay between calls. Use if the Process loop blocks execution on its own, for instance to wait for DAQ samples to be ready.
    - On Data Ready: Run process whenever data arrives on the Input stream. Use for sink or process PEs that process input data that comes from another plugin.  Do not use for data source plugins.  Use this instead of Periodic to avoid memory growth.
    - Triggered: Use if you configure triggering on the Input stream to only receive data when a trigger condition applies.
  - Most plugins will use Immediate if they are the source of data or On Data Ready if they are a sink of data.
- ### Read Parameters
  - You do not need to edit this function.  
  - This function loads in the configuration parameters for the plugin (for example, the file path to log to or the CAN interface name to read from)
- ### Configure Session
  - Called once per session, and is always called after the plugin loads its configuration
  - For the ADAS use case, we typically only have a single session of a plugin during a run.  In the future we may add the ability to support multiple sessions.
  - In this VI, take the configuration parameters and call the appropriate initialization functions to open and store any references needed during the run.  For example, call Open/Create/Replace File on the path stored in configuration and store the file reference as part of the class private data for the plugin class.
  - If your plugin needs information from the configuration to decide what timing parameters to use (for example, to configure the period of a Periodic timing), set those here instead of in the Initialize function.
- ### Process
  - This is where the vast majority of the work done by your plugin will happen.  Here, your plugin can read the data that was sent to the plugin (if any), perform some action(s), and optionally send data to the PEF Engine for other plugins to receive.
  - The Process state gets called repeatedly by the engine.  You do not need to implement a while loop to continuously run in the Process state.  Your process state must not call any code with an infinite timeout.  Instead, use a defined timeout and handle/ignore the timeout error accordingly.  This ensures that the system does not hang or get stuck.
  - There may be many instances of the same plugin running on the system.  Because the state VIs in plugins run with Shared Clone reentrancy, there is no guarantee that any data stored in diagram or front panel structures (such as feedback nodes, shift registers, front panel objects, etc) are from the same instance of the plugin.  Any data that needs to persist between calls to the Process VI must be persisted in the class private data of the plugin.
  - If you are making a logging plugin that records raw data sent to the plugin to TDMS, your process function might look something like this:
![image.png](/.attachments/image-f9a351c4-eaf7-48f2-afb2-bcd27bc1e4b0.png)
     - In this case, you'd use the Read String method (C:\Program Files\National Instruments\LabVIEW 2020\vi.lib\ADAS Record\PEFClasses\Extensions\PEF System Interface\Read String.vi) to get the raw string and write it to the TDMS file reference stored in the class private data.
        - Usually, the data coming in would need to be unflattened to a different data type than string (such as an array of CAN frames) and the timestamp from the Read String function logged as a separate channel in the TDMS file.  This example comes from an early prototype of the TDMS plugin.
     - Since this is purely a data sink, we do not write any data out to the ADAS engine.
   - If you are making a plugin that generates data (such as a UDP reader, or a plugin to get data from a CAN board), often the Process VI will look more like this:
![image.png](/.attachments/image-33d1a712-4044-440c-b974-c6aaa5abd924.png)
   - For more details around using CustomData, see [this article.](https://dev.azure.com/ni/DevCentral/_wiki/wikis/AppCentral.wiki/15306/Cleanup-Custom-Data)
- ### Handle Processing Error
  - This function gets called by the engine if an error occurs in the Process override (if the value of the error out terminal of the Process VI shows an error).  In this function, you can choose what action the engine should take when errors occur.  By default, any error results in the plugin immediately calling its cleanup and finalize states.  You can add a case structure to take different actions for different errors.
  - This function is not present by default in the project generated by the template.  If you want to have different behavior than the default, right click on the States folder in the project and select New VI for override, then select the Handle Processing Error method
  - ![image.png](/.attachments/image-230f7aba-00c2-45c1-bc05-4fc5ef6f2497.png)
  - There are three options for the action the plugin should take when an error is detected:
    - Cleanup and Finalize (default): This calls the Cleanup Session and Finalize states of the plugin, after which the plugin is stopped and not running.
    - Cleanup and Configure: This calls the Cleanup Session and then the Configure Session states.  This is equivalent to resetting the plugin and trying to run it again.  The plugin is running and can enter its Process state based on how its timing configuration.
    - Report and Continue: This option reports the error to the debug stream and lets the plugin continue running.  This is equivalent to ignoring the error.
- ### Handle Message
  - This method allows the plugin to register for and take action when certain messages are received (for example, "Start Logging" or "Stop Logging").  By default, plugins just record the message and timestamp to the debug data stream and take no additional action.
  - This method needs additional documentation and examples before it can be easily used.  If you need this, currently you need to ask Systems R & D how to use it.
  - This method runs in a separate thread from the Process VI - any changes made to the class private data of the plugin class will not normally be reflected in the Process VI, since that has a different copy of the class private data.  To communicate changes to the Process VI (for example, to set a flag for 'logging enabled'), wrap the shared data in a DVR and maintain the DVR as part of the class private data.  The DVR should be initialized in the "Initialize" state, modified in the "Configure Session" state if its value depends on the configuration, read in the "Process" state, and destroyed in the "Finalize" state.
- ### Cleanup Session
  - This method is used to close any references opened in Configure Session and flush any buffers used.  
  - This method is followed by either Configure Session (if the plugin is restarting) or Finalize (if the plugin is shutting down)
- ### Finalize
  - This method is called as the plugin is shut down.  If there are any short-duration post-processing actions (such as writing a summary/index file of data just recorded by the plugin) or lifetime references (like DVRs of shared data used with the Handle Message method), take care of those here.

## Testing
[Testing plugins - resource page](https://ni.visualstudio.com/DevCentral/_wiki/wikis/AppCentral.wiki/14664/Testing-and-Debugging-ADAS-IO-Plugins)
## Deployment
<insert details on where plugins get installed and how they are built here>
  
 
  
